<doctype html>
    <html>

    <head>
        <title>Basketball_reboot</title>
        <link rel="stylesheet" href="Style/index.css">
        <script type="text/javascript" src="Matrix_Utils/matrix_utils.js"></script>
        <script type="text/javascript" src="ScreenQuad/screen_quad.js"></script>
        <script type="text/javascript" src="Spheres/sphere.js"></script>
        <script type="text/javascript" src="RayTracing/ray_tracing.js"></script>
        <script type="text/javascript" src="project6.js"></script>
        <script type="text/javascript" src="project7.js"></script>
        <script type="text/javascript" src="obj.js"></script>
        <script type="text/javascript" src="Cube/vertex_selection_color.js"></script>
        <script type="text/javascript" src="Light/light.js"></script>
        <script type="text/javascript" src="BoundingBox/boundingbox.js"></script>

        <script type="text/javascript" src="Arena/arena.js"></script>
        <script type="text/javascript" src="MassSpringSimulation/mass_spring_simulation.js"></script>
        <script type="text/javascript" src="Vec3/vec3.js"></script>

        <!--SHADER -->
        <script id="raytraceVS" type="x-shader/x-vertex">
            attribute vec3 p;
            uniform mat4 proj;
            uniform mat4 c2w; //camera to world
            varying vec3 ray_pos;
            varying vec3 ray_dir;
            void main()
            {
                gl_Position = proj * vec4(p,1);
                vec4 rp = c2w * vec4(0,0,0,1);
                ray_pos = rp.xyz;
                vec4 rd = c2w * vec4(p,1);
                ray_dir = rd.xyz - ray_pos;
            }
        </script>

        <script id="envFS" type="x-shader/x-fragment">
            precision mediump float;
            varying vec3 ray_dir;
            uniform samplerCube envMap;
            void main()
            {
                gl_FragColor = textureCube( envMap, ray_dir.xzy );
            }
        </script>
        <script id="sphereVS" type="x-shader/x-vertex">
            attribute vec3 p;
            uniform mat4  mvp;
            uniform vec3  center;
            uniform float radius;
            varying vec3 pos;
            varying vec3 normal;
            void main()
            {
                pos = p*radius + center;
                gl_Position = mvp * vec4(pos,1);
                normal = p;
            }
            </script>



            
            
            <script id="sphereFS" type="x-shader/x-fragment">
            precision mediump float;
            struct Material {
                vec3  k_d;	// diffuse coefficient
                vec3  k_s;	// specular coefficient
                float n;	// specular exponent
            };
            struct Light {
                vec3 position;
                vec3 intensity;
            };
            uniform samplerCube envMap;
            uniform Light    light;
            uniform vec3     campos;
            uniform Material mtl;
            varying vec3     pos;
            varying vec3     normal;
            void main()
            {
                vec3 nrm = normalize(normal);
                vec3 view = normalize( campos - pos );
                vec3 color = vec3(0,0,0);
                vec3 L = normalize( light.position - pos );
                float c = dot( nrm, L );
                if ( c > 0.0 ) {
                    vec3 clr = c * mtl.k_d;
                    vec3 h = normalize( L + view );
                    float s = dot( nrm, h );
                    if ( s > 0.0 ) {
                        clr += mtl.k_s * pow( s, mtl.n );
                    }
                    color += clr * light.intensity;
                }
                if ( mtl.k_s.r + mtl.k_s.g + mtl.k_s.b > 0.0 ) {
                    vec3 dir = reflect( -view, nrm );
                    color += mtl.k_s * textureCube( envMap, dir.xzy ).rgb;
                }
                gl_FragColor = vec4(color,1);
            }
            
            </script>
            
            
        <!-- -- -->

        <!-- VARIABILI -->
        <script>
            var viewRotX = 0, viewRotZ = 0, transZ = 3,transY=0,MV;
            const transZmin = 1.001;
            const transZmax = 10;
            var canvas, gl, background, perspectiveMatrix;
            var sphereDrawer;//,triSphere;
            var environmentTexture;
            const maxBounceLimit = 16;
            var primaryRT, secondaryRT;
            var boxDrawer, showBox;
            var massSpring,MVP,lightView;

            //var spheres;

            var lights = [
	        {
		        position:  [ 0, 0, 1000 ],
		        intensity: [ 1, 1, 1 ]
	        }
            
];

/*var fixed_spheres = [
	{
		center: [ 0, 0, -10001.0 ],
		radius: 10000.0,
		mtl: {
			k_d: [ 0.1, 0.1, 0.2 ],
			k_s: [ 0.2, 0.2, 0.2 ],
			n: 10
		}
	},
	{
		center: [ 0, 0, 0 ],
		radius: 1.0,
		mtl: {
			k_d: [ 0.5, 0.0, 0.0 ],
			k_s: [ 0.8, 0.8, 0.8 ],
			n: 100
		}
	},
];
var spheres = fixed_spheres.slice();*/

        </script>
        <!-- --------- -->

        <script>
            function InitEnvironmentMap() {
                environmentTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, environmentTexture);

                const url = 'http://localhost:3000/';
                const files = [
                    'px.png',
                    'nx.png',
                    'py.png',
                    'ny.png',
                    'pz.png',
                    'nz.png',
                ];
                const faces = [
                    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                ];

                var loaded = 0;
                for (var i = 0; i < 6; ++i) {
                    gl.texImage2D(faces[i], 0, gl.RGBA, 128, 128, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.face = faces[i];
                    img.onload = function () {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, environmentTexture);
                        gl.texImage2D(this.face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this);
                        loaded++;
                        if (loaded == 6) {
                            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                            DrawScene();
                        }
                    };
                    img.src = url + files[i];
                }
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                
            }
            function InitWebGL() {
                // Initialize the WebGL canvas
                canvas = document.getElementById("canvas");
                canvas.oncontextmenu = function () { return false; };
                gl = canvas.getContext("webgl2", { antialias: false, depth: true });	// Initialize the GL context
                if (!gl) {
                    alert("Unable to initialize WebGL. Your browser or machine may not support it.");
                    return;
                }

                // Initialize settings
                gl.clearColor(0, 0, 0, 0);
                gl.enable(gl.DEPTH_TEST);
                

                InitEnvironmentMap();
                //triSphere = new TriSphereClass(20,gl);
                background = new BackGround(gl);
                //console.log(gl)
                
                /*sphereDrawer = new SphereDrawer(20,gl);
                var meshDrawer = new MeshDrawer();
	            sphereDrawer.setLight( lights[0].position, lights[0].intensity );
                sphereDrawer.addSphere(new Sphere([ 0, 0, 0 ],1.0,{
                    k_d: [ 0.5, 0.0, 0.0 ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                    },gl,20,meshDrawer));
                sphereDrawer.addSphere(new Sphere([ 2, 0, 0 ],1,{
                    k_d: [ 0.5, 0.0, 0.0 ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                    },gl,20,meshDrawer
                ))*/
                //spheres = sphereDrawer.spheres;
                //primaryRT   = new PrimaryRayTracer(gl,background.screenQuad);
	            
                //secondaryRT = new SecondaryRayTracer(20,background,sphereDrawer,gl);
                boxDrawer = new BoxDrawer()
                UpdateCanvasSize();
                //console.log("si")
                massSpring = new MassSpring(true,"1");
                //console.log(lights.position)
                massSpring.meshDrawer.setLightDir_old(0,0,1)
                //massSpring.meshDrawer.setLightDir([0,0,1000],[1,1,1])
                //massSpring.meshDrawer.setMaterial([ 0.5, 0.5, 0.0 ],[ 0.8, 0.8, 0.8 ],100,[ 0, 0, 0 ],1.0)
                massSpring.meshDrawer.showTexture(false);
                SetGravity  ( document.getElementById('gravity') );
                SetMass     ( document.getElementById('mass') );
                SetStiffness( document.getElementById('stiffness') );
                //SetShininess( document.getElementById('shininess-exp') );
                
                //console.log(["masspsring",massSpring])

                //primaryRT.init(sphereDrawer.spheres,lights,maxBounceLimit);
	            //secondaryRT.init(sphereDrawer.spheres,lights,maxBounceLimit);
               
                //massSpring = new MassSpring(false,"1",sphereDrawer.spheres[0].triSphere.b.pos)
                //InitScene();
            }
            function UpdateCanvasSize() {
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                const pixelRatio = window.devicePixelRatio || 1;
                canvas.width = pixelRatio * canvas.clientWidth;
                canvas.height = pixelRatio * canvas.clientHeight;
                const width = (canvas.width / pixelRatio);
                const height = (canvas.height / pixelRatio);
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                gl.viewport(0, 0, canvas.width, canvas.height);
                UpdateProjectionMatrix();
            }
            function UpdateProjectionMatrix() {
                const fov = 60;
                var r = canvas.width / canvas.height;
                var n = 0.1;
                const min_n = 0.001;
                if (n < min_n) n = min_n;
                var f = transZmax * 100;
                var ff = Math.PI * fov / 180;
                var tant_2 = Math.tan(ff / 2);
                var s = 1 / tant_2;
                perspectiveMatrix = [
                    s / r, 0, 0, 0,
                    0, s, 0, 0,
                    0, 0, -(n + f) / (f - n), -1,
                    0, 0, -2 * n * f / (f - n), 0
                ];
                //console.log("ene")

                MV = GetModelViewMatrix( 0, transY, transZ, viewRotX, viewRotZ );
                var trans = GetTrans();
                MVP = MatrixMult(perspectiveMatrix, trans.worldToCam);


                 
                //screenQuad.init(fov, (n + f) / 2); can be removed
                background.updateProj(fov, (n + f) / 2);
                //primaryRT.updateProj();
                //secondaryRT.updateProj();
            }

            function DrawScene() {
                gl.flush();
                //console.log(document.getElementById('show-texture').param.checked)
                /*if(document.getElementById('show-texture').param===undefined){
                    console.log("si");
                    massSpring.meshDrawer.showTexture(false);
                }*/
                var trans = GetTrans();
                //console.log(perspectiveMatrix)
                //console.log(perspectiveMatrix)

                var mvp = MatrixMult(perspectiveMatrix, trans.worldToCam);

                var nrm = [ MV[0],MV[1],MV[2], MV[4],MV[5],MV[6], MV[8],MV[9],MV[10] ];
                //MVP = mvp;
                // Clear the screen and the depth buffer.
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                background.draw(trans);
                if(showBox.checked){
                    boxDrawer.draw(mvp);

                }
                // Rasterization
                if ( document.getElementById('raster').checked ) {
                    background.draw( trans );
                    //sphereDrawer.setTrans( mvp, [ trans.camToWorld[12], trans.camToWorld[13], trans.camToWorld[14] ] );
                    //sphereDrawer.spheres.forEach( s => sphereDrawer.draw(s,mvp,MV,nrm) );
                    massSpring.boundingBox.draw(mvp);
                    massSpring.meshDrawer.draw(mvp,MV,nrm,[ trans.camToWorld[12], trans.camToWorld[13], trans.camToWorld[14] ]);
                    massSpring.pointDrawer.draw(mvp);


                }
            	
                // Ray Tracing
                if ( document.getElementById('raytrace').checked ) {
                    primaryRT.draw( trans );
                }
            	
                // Rasterization + Ray Tracing
                if ( document.getElementById('secondary').checked ) {
                    secondaryRT.draw( mvp, trans );
                }
            }

            function InitShaderProgramFromScripts(vs, fs) {
                return InitShaderProgram(document.getElementById(vs).text, document.getElementById(fs).text);
            }

            // This is a helper function for compiling the given vertex and fragment shader source code into a program.
            function InitShaderProgram(vsSource, fsSource) {
                const vs = CompileShader(gl.VERTEX_SHADER, vsSource);
                const fs = CompileShader(gl.FRAGMENT_SHADER, fsSource);

                if (!vs || !fs) return null;

                const prog = gl.createProgram();
                gl.attachShader(prog, vs);
                gl.attachShader(prog, fs);
                gl.linkProgram(prog);

                if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(prog));
                    return null;
                }
                return prog;
            }

            // This is a helper function for compiling a shader, called by InitShaderProgram().
            function CompileShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert('An error occurred compiling shader:\n' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }



        </script>

        <script>


            window.onload = function () {
                showBox = document.getElementById('show-box');
                document.getElementById('show-texture').checked = false;

                InitWebGL();

                canvas.zoom = function (s) {
                    transZ *= s / canvas.height + 1;
                    if (transZ < transZmin) transZ = transZmin;
                    if (transZ > transZmax) transZ = transZmax;
                    UpdateProjectionMatrix();
                    DrawScene();
                }
                canvas.onwheel = function () { canvas.zoom(0.3 * event.deltaY); }
                canvas.onmousedown = function () {
                    if ( massSpring.mouseDown() ) {
			            canvas.ondblclick = null;
			            return;
		            }
                    canvas.ondblclick = canvas.resetView;

                    var cx = event.clientX;
                    var cy = event.clientY;
                    if (event.ctrlKey) {
                        canvas.onmousemove = function () {
                            canvas.zoom(5 * (event.clientY - cy));
                            cy = event.clientY;
                        }
                    } else {
                        canvas.onmousemove = function () {
                            viewRotZ += (cx - event.clientX) / canvas.width * 5;
                            //console.log(viewRotZ);
                            viewRotX -= (cy - event.clientY) / canvas.height * 5;
                            cx = event.clientX;
                            cy = event.clientY;
                            const eps = 0.01;
                            if (viewRotX < -0.1) viewRotX = -0.1;
                            if (viewRotX > Math.PI / 2 - eps) viewRotX = Math.PI / 2 - eps;
                            UpdateProjectionMatrix();
                            DrawScene();
                        }
                    }
                }
                canvas.onmouseup = canvas.onmouseleave = function () {
                    massSpring.mouseUp();
		            canvas.onmousemove = function() { massSpring.mouseMove(); }
                }

                DrawScene();
            };
            function WindowResize() {
                UpdateCanvasSize();
                DrawScene();
            }
            function MousePos()
                {
                return {
                 x:  ( event.clientX / canvas.clientWidth  ) * 2 - 1,
                    y: -( event.clientY / canvas.clientHeight ) * 2 + 1
                }; 
            }     
        
            function ShowTexture( param )
            {
                //console.log("elle",param.checked)
                massSpring.meshDrawer.showTexture( param.checked );
                DrawScene();
            }
            function LoadObj( param )
{
	if ( param.files && param.files[0] ) {
		var reader = new FileReader();
		reader.onload = function(e) {
			massSpring.setMesh( e.target.result );
            DrawScene();

		}
		reader.readAsText( param.files[0] );
        console.log("finito");
	}
}

        function LoadTexture( param )
{
            if ( param.files && param.files[0] ) {
                var reader = new FileReader();
                reader.onload = function(e) {
                    var img = document.getElementById('texture-img');
                    img.onload = function() {
                        

                        massSpring.meshDrawer.setTexture( img );
                        var checkbox = document.getElementById('show-texture');
                        checkbox.checked = true;
        
                        // Trigger the onchange event
                        var event = new Event('change');
                        checkbox.dispatchEvent(event);
                        DrawScene();
                    }
                    img.src = e.target.result;
                };
                reader.readAsDataURL( param.files[0] );
                /*document.getElementById('show-texture').checked = true;
                massSpring.meshDrawer.setTexture(true);*/
            }
}

            function UseEnvironmentMap(param) {

                gl.bindTexture(gl.TEXTURE_CUBE_MAP, param.checked ? environmentTexture : null);
                DrawScene();
            }
            function IncBounceLimit( inc )
{
	var b = parseInt(document.getElementById('bounces-value').innerText);
	b += inc;
	if ( b < 0 ) b = 0;
	if ( b > maxBounceLimit ) b = maxBounceLimit;
	SetBounceLimit( b );
	document.getElementById('bounces-range').value = b;
}

function SetBounceLimit( b )
{
	document.getElementById('bounces-value').innerText = b;
	primaryRT.setBounceLimit( b );
	secondaryRT.setBounceLimit( b );
	UpdateProjectionMatrix();
	DrawScene();
}
function ShowControls()
{
	var c = document.getElementById('controls');
	c.style.display = c.style.display == 'none' ? '' : 'none';
}
function SetGravity( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('gravity-value').innerText = s.toFixed( 2 );
	massSpring.gravity.y = -s;
}

function SetMass( param )
{
	var v = param.value;
	var s = v / 200;
	document.getElementById('mass-value').innerText = s.toFixed( 3 );
	massSpring.mass = s;
}

function SetStiffness( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('stiffness-value').innerText = s.toFixed( 2 );
	massSpring.stiffness = s;
}

function SetDamping( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('damping-value').innerText = s.toFixed( 2 );
	massSpring.damping = s;
}

function SetShininess( param )
{
	var exp = param.value;
	var s = Math.pow(10,exp/25);
	document.getElementById('shininess-value').innerText = s.toFixed( s < 10 ? 2 : 0 );
	meshDrawer.setShininess(s);
	DrawScene();
}
function SetTimeStepSize( param )
{
	var s = param.value;
	document.getElementById('timestep-value').innerText = s + " ms";
}
</script>

<script id="sphereee" type="text/obj">
    v  -1  1 -1
	v  -1 -1 -1
	v   1 -1 -1
	v   1  1 -1
	v   1 -1  1
	v  -1 -1  1
	v  -1  1  1
	v   1  1  1
	vn  0  0  1
	vn  0  0  1
	vn  0  0  1
	vn  0  0  1
	vn  0  0 -1
	vn  0  0 -1
	vn  0  0 -1
	vn  0  0 -1
	vn  0  1  0
	vn  0  1  0
	vn  0  1  0
	vn  0  1  0
	vn -1  0  0
	vn -1  0  0
	vn -1  0  0
	vn -1  0  0
	vn  0 -1  0
	vn  0 -1  0
	vn  0 -1  0
	vn  0 -1  0
	vn  1  0  0
	vn  1  0  0
	vn  1  0  0
	vn  1  0  0
	vt 0 0
	vt 0 1
	vt 1 1
	vt 1 0
	f 1/1/1  4/4/4  3/3/3  2/2/2  
	f 5/1/5  8/4/8  7/3/7  6/2/6  
	f 3/1/9  5/4/12 6/3/11 2/2/10 
	f 4/1/13 8/4/16 5/3/15 3/2/14 
	f 1/1/17 7/4/20 8/3/19 4/2/18 
	f 2/1/21 6/4/24 7/3/23 1/2/22 
</script>
    </head>

    <body onresize="WindowResize()">
<div id="canvas-div"><canvas id="canvas"></canvas></div><div id="controls-div">
<div id="buttons"><input type="button" value="V" onclick="ShowControls()"/></div>
<div id="controls">
<div class="control-group">
<div class="control"><input id="raster" name="method" type="radio" onchange="DrawScene()" checked/><label for="raster"> Rasterization</label><br/></div>
<div class="control"><input id="raytrace" name="method" type="radio" onchange="DrawScene()"  /><label for="raytrace"> Ray Tracing</label><br/></div>
<div class="control"><input id="secondary" name="method" type="radio" onchange="DrawScene()" /><label for="secondary"> Rasterization + Ray Tracing</label><br/></div>
<div class="control"><hr/></div>
<div class="control"><input id="envmap" name="envmap" type="checkbox" onchange="UseEnvironmentMap(this)"  /><label for="envmap"> Environment Map</label></div>
<div class="control"><span id="bounces-label">Bounce Limit:</span><span class="val"><span class="value" id="bounces-value">5</span><input type="button" value="+" onclick="IncBounceLimit(1)"><input type="button" value="&ndash;" onclick="IncBounceLimit(-1)"></span><input id="bounces-range" type="range" min="0" max="16" value="5" oninput="SetBounceLimit(this.value)"/></div>
<div class="control"><span id="count-label">Sphere Count:</span><span class="val"><span class="value" id="count-value">10</span><input type="button" value="+" onclick="IncCount(1)"><input type="button" value="&ndash;" onclick="IncCount(-1)"></span><input id="count-range" type="range" min="1" max="100" value="10" oninput="SetCount(this.value)" onchange="NewScene()"/></div>
<div class="control"><input type="button" class="btn" value="New Random Scene" onclick="NewScene()"></div>
<div class="control"><input id="show-box" name="show-box" type="checkbox" onchange="DrawScene()" checked /><label for="show-box"> Show Box</label></div>

</div>
<div class="control-group">
    <div class="control"><input type="button" value="Start Simulation" onclick="massSpring.toggleSimulation(this)"></div>
    <div class="control"><input type="button" value="Reset" onclick="massSpring.reset();DrawScene()"></div>
    <div class="control"><span id="timestep-label">Time Step Size:</span><span class="value" id="timestep-value">20 ms</span><input id="timestep" type="range" min="1" max="100" value="20" oninput="SetTimeStepSize(this)" onchange="massSpring.restartSimulation()" ondblclick="this.value=20;this.oninput();this.onchange()"/></div>
    <div class="control"><span id="gravity-label">Gravity:</span><span class="value" id="gravity-value">1</span><input id="gravity" type="range" min="0" max="100" value="20" oninput="SetGravity(this)" ondblclick="this.value=20;this.oninput()"/></div>
    <div class="control"><span id="mass-label">Mass:</span><span class="value" id="mass-value">1</span><input id="mass" type="range" min="1" max="100" value="20" oninput="SetMass(this)" ondblclick="this.value=20;this.oninput()"/></div>
    <div class="control"><span id="stiffness-label">Stiffness:</span><span class="value" id="stiffness-value">1</span><input id="stiffness" type="range" min="0" max="100" value="20" oninput="SetStiffness(this)" ondblclick="this.value=20;this.oninput()"/></div>
    <div class="control"><span id="damping-label">Damping:</span><span class="value" id="damping-value">1.00</span><input id="damping" type="range" min="0" max="100" value="20" oninput="SetDamping(this)" ondblclick="this.value=20;this.oninput()"/></div>
    <div class="control">Texture image:<br/><input id="texture" type="file" onchange="LoadTexture(this)" accept="image/*"/></div>
    <div class="control"><img id="texture-img" /></div>

    <div class="control"><input id="show-texture" name="show-texture" type="checkbox" onchange="ShowTexture(this)"  /><label for="show-texture"> Show Texture</label></div>
    <div class="control">OBJ model:<br/><input id="obj" type="file" onchange="LoadObj(this)" accept=".obj"/></div>
    <div class="control" id="score">Score: 0<br/></div>

</div>
</div>
</div>
</div>
</body>

    </html>